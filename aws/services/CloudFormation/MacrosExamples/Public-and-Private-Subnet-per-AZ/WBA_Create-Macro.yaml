AWSTemplateFormatVersion: 2010-09-09
Description: Public Subnet per AZ Macro Template

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: WBA Cost Allocation tags
        Parameters:
          - OwnerTag
          - ProjectTag
          - EnvironmentTag
      - Label:
          default: WBA Lineage/Lifecycle tags
        Parameters:
          - CreatedByTag
          - CreatedDateTag
          - CreatedMethodTag
      - Label:
          default: WBA Stewardship tags
        Parameters:
          - TeamTag
          - DeleteAfterTag

Parameters:
  OwnerTag:
    Type: String
    Description: Value for the "Owner" tag of resources created by the stack used to indicate who owns the stack.
    Default: WBA
    ConstraintDescription: Must be WBA or the legacy SwarmAnalytics.
  ProjectTag:
    Type: String  
    Description: Value for the "Project" of the resrouces in the stack used to indciate who is charged for the stack or what WBA paid for project or system it is part of.
    ConstraintDescription: Must be project name searchable in Jira tickets, game studio name, or a WBD department name.
  EnvironmentTag: 
    Type: String
    Description: Value for the "Environment" tag of the resources created by the stack.
    AllowedValues:
       - prod
       - nonprod
       - prerelease
       - alpha
       - beta
       - dev
       - test
       - qa
       - staging
    Default: dev
    ConstraintDescription: The value prod, nonprod, prerelease, alpha, beta, prerelease may be used for game environments we provide to customers. All others are internal to WBA only. 
  CreatedByTag:
    Type: String
    Description: Value for the "created_by" tac of the resources created by the stack.
    Default: <your_emailname>@<WBD_email_domain>.com
    ConstraintDescription: Must be a valid WDB email address that matches your Okta credentials.
  CreatedDateTag:
    Type: String 
    Description: Value for the "created_date" tag of resources created by the stack. 
    AllowedPattern: '(\d{1,2})/(\d{1,2})/(\d{4,4})'
    ConstraintDescription: Today's date in MM/DD/YYYY format.
  CreatedMethodTag:
    Type: String
    Description: Value for the "created_method" tag of resources created by the stack. 
    AllowedValues:
       - console
       - CloudFormation
       - Terraform
       - CLI
       - API
    Default: CloudFormation
  TeamTag:
    Type: String
    Description: Value for the "team" tag of resources created by the stack used to identify the WBA/DPT team responsible for managing the resources.
    AllowedValues: 
       - DevOps
       - DE
       - DBA
       - Apps
       - Pricing and Experimentation
       - Game Data Pros
       - Exostatic
       - Keitaro
  DeleteAfterTag:
    Type: String 
    Description: The date for the "delete_after" tag of resources created by the stack used to indicate the intented end-of-life for the stack. 
    AllowedPattern: '(((\d{1,2})/(\d{1,2})/(\d{4,4}))|indefinite)'
    Default: 01/01/2000
    ConstraintDescription: A future date in MM/DD/YYYY format.

Resources:
    TransformExecutionRole:
        Type: AWS::IAM::Role
        Properties:
            AssumeRolePolicyDocument:
                Version: 2012-10-17
                Statement:
                    - Effect: Allow
                      Principal:
                        Service: [lambda.amazonaws.com]
                      Action: ['sts:AssumeRole']
            Path: /
            Policies:
                - PolicyName: root
                  PolicyDocument:
                    Version: 2012-10-17
                    Statement:
                        - Effect: Allow
                          Action: ['logs:*']
                          Resource: 'arn:aws:logs:*:*:*'
                        - Effect: Allow
                          Action: ['ec2:*']
                          Resource: '*'
            Tags:
                - Key: Name
                  Value: 'Public_Subnet_per_AZ_Macro_Role'
                - Key: Owner
                  Value: !Ref OwnerTag
                - Key: Project
                  Value: !Ref ProjectTag
                - Key: Environment
                  Value: !Ref EnvironmentTag
                - Key: created_by
                  Value: !Ref CreatedByTag
                - Key: create_date
                  Value: !Ref CreatedDateTag
                - Key: delete_after
                  Value: !Ref DeleteAfterTag
                - Key: created_method
                  Value: !Ref CreatedMethodTag
                - Key: team
                  Value: !Ref TeamTag

    TransformFunctionPermissions:
        Type: AWS::Lambda::Permission
        Properties:
            Action: 'lambda:InvokeFunction'
            FunctionName: !GetAtt TransformFunction.Arn
            Principal: 'cloudformation.amazonaws.com'

    TransformFunction:
        Type: AWS::Lambda::Function
        Properties:
            Code:
                ZipFile: |
                  import boto3
                  import copy
                  import math
                  import logging  
                  logger = logging.getLogger()
                  logger.setLevel(logging.INFO)
                  # logger.setLevel(logging.DEBUG)

                  def handler(event, context):

                    # Function Inputs
                    logger.info('Input Event: event{}'.format(event))
                    logger.info('Input Context: event{}'.format(context))
                    
                    # Globals
                    region = event['region']
                    accountId = event['accountId']
                    fragment = event['fragment']
                    transformId = event['transformId']
                    params = event['params']
                    requestId = event['requestId']
                    templateParameterValues = event['templateParameterValues']
                    logger.info('Parameters event{}'.format(templateParameterValues))

                    ec2 = boto3.client('ec2', region_name=region)

                    # Retrieves availability zones for this region
                    response = ec2.describe_availability_zones()
                    AZs = response['AvailabilityZones']

                    # Override the number of AZs in the region if an explicit max number of AZ was requested. 
                    logger.info('MaxAZs: {}'.format(templateParameterValues['MaxAZs']))
                    maxAZstring = templateParameterValues['MaxAZs']
                    maxAZs = int(maxAZstring)
                    if maxAZs > 0:
                      numAZs = maxAZs
                    else:
                      numAZs = len(AZs)

                    #Grab resources that need to be duplicated
                    VPCPubSn1 = fragment['Resources']['VPCPubSn1']
                    VPCPrivSn1 = fragment['Resources']['VPCPrivSn1']
                    PubSnRtAssoc1 = fragment['Resources']['VPCPubSn1RtAssoc']
                    PubSnRtAssoc1 = fragment['Resources']['VPCPrivSn1RtAssoc']
                    StackVPCPubSn1 = fragment['Outputs']['StackVPCPubSn1']
                    StackVPCPrivSn1 = fragment['Outputs']['StackVPCPrivSn1']

                    # Compute the number of subnet CIDR blocks and the number CIDR bits need.
                    # The formula for the next highest power of 2 is 2**(math.ceil(math.log2(n))).
                    # Removing the power of 2 gives the number of bits needed or (math.ceil(math.log2(n))).
                    # So the biggest subnets are VPC CIDR bits - the number of bits in the next highest power of 2
                    # relative to the number for subnets or n in the formula.
                    logger.info('VPCNetMaskLength: {}'.format(templateParameterValues['VPCNetMaskLength']))
                    vpcCIDRbits = templateParameterValues['VPCNetMaskLength']
                    logger.info('vpcCIDRbits: %d', int(vpcCIDRbits) )
                    subnetCIDRs = numAZs * 2
                    logger.info('subnetCIDRs: %d', subnetCIDRs )
                    subnetCIDRbits = ( (32 - int(vpcCIDRbits)) - (math.ceil(math.log2(subnetCIDRs))) )
                    logger.info('subnetCIDRbits: %d', subnetCIDRbits )

                    # iterate and add new resources
                    for i in range(1,numAZs+1): # Create a range from 1 - numAZs

                      logger.info('Macro replication loop index: %d', i)

                      # Override the CIDR for the Public Subnet of VPCPubSN1 in the first AZ.
                      if i == 1:   
                        fragment['Resources']['VPCPubSn' + str(i)]['Properties']['AvailabilityZone']['Fn::Select'][0] = str(i - 1)
                        fragment['Resources']['VPCPubSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][0] = str(i - 1)
                        fragment['Resources']['VPCPubSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][1]['Fn::Cidr'][1] = subnetCIDRs
                        fragment['Resources']['VPCPubSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][1]['Fn::Cidr'][2] = subnetCIDRbits
                        logger.info('PubSn' + str(i) + ' after AZ:    {}'.format(fragment['Resources']['VPCPubSn' + str(i)]['Properties']['AvailabilityZone']['Fn::Select'][0]))
                        logger.info('PubSn' + str(i) + ' after CIDR index:  {}'.format(fragment['Resources']['VPCPubSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][0]))
                        logger.info('PubSn' + str(i) + ' after CIDR:  {}'.format(fragment['Resources']['VPCPubSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][1]))
                      # Append all the additional Public Subnets onto the fragment.
                      else:        
                        # Create new Public Subnet based off of VPCPubSN1
                        fragment['Resources']['VPCPubSn' + str(i)] = copy.deepcopy(VPCPubSn1)
                        fragment['Resources']['VPCPubSn' + str(i)]['Properties']['AvailabilityZone']['Fn::Select'][0] = str(i - 1)
                        fragment['Resources']['VPCPubSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][0] = str(i - 1)
                        fragment['Resources']['VPCPubSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][1]['Fn::Cidr'][1] = subnetCIDRs
                        fragment['Resources']['VPCPubSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][1]['Fn::Cidr'][2] = subnetCIDRbits
                        logger.info('PubSn' + str(i) + ' after AZ:     {}'.format(fragment['Resources']['VPCPubSn' + str(i)]['Properties']['AvailabilityZone']['Fn::Select'][0]))
                        logger.info('PubSn' + str(i) + ' after CIDR: {}'.format(fragment['Resources']['VPCPubSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][1]))
                        logger.info('PubSn' + str(i) + ' after CIDR:   {}'.format(fragment['Resources']['VPCPubSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][1]))
                        next_name = '${VPCName}_vpc_public_subnet_' + str(i)
                        logger.info('PubSn' + str(i) + ' New_value     {}'.format(next_name))
                        fragment['Resources']['VPCPubSn' + str(i)]['Properties']['Tags'][0]['Value']['Fn::Sub'] = next_name

                      # Override the CIDR for the Private Subnet of VPCPrivSN1 in the first AZ.
                      if i == 1:   
                        fragment['Resources']['VPCPrivSn' + str(i)]['Properties']['AvailabilityZone']['Fn::Select'][0] = str(i - 1)
                        fragment['Resources']['VPCPrivSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][0] = (numAZs*2) - i
                        fragment['Resources']['VPCPrivSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][1]['Fn::Cidr'][1] = subnetCIDRs
                        fragment['Resources']['VPCPrivSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][1]['Fn::Cidr'][2] = subnetCIDRbits
                        logger.info('PrivSn' + str(i) + ' after AZ:    {}'.format(fragment['Resources']['VPCPrivSn' + str(i)]['Properties']['AvailabilityZone']['Fn::Select'][0]))
                        logger.info('PrivSn' + str(i) + ' after CIDR index:  {}'.format(fragment['Resources']['VPCPrivSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][0]))
                        logger.info('PrivSn' + str(i) + ' after CIDR:  {}'.format(fragment['Resources']['VPCPrivSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][1]))
                      # Append all the additional Private Subnets onto the fragment.
                      else:        
                        # Create new Private Subnet based off of VPCPrivSN1
                        fragment['Resources']['VPCPrivSn' + str(i)] = copy.deepcopy(VPCPrivSn1)
                        fragment['Resources']['VPCPrivSn' + str(i)]['Properties']['AvailabilityZone']['Fn::Select'][0] = str(i - 1)
                        fragment['Resources']['VPCPrivSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][0] = (numAZs*2) - i
                        fragment['Resources']['VPCPrivSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][1]['Fn::Cidr'][1] = subnetCIDRs
                        fragment['Resources']['VPCPrivSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][1]['Fn::Cidr'][2] = subnetCIDRbits
                        logger.info('PrivSn' + str(i) + ' after AZ:    {}'.format(fragment['Resources']['VPCPrivSn' + str(i)]['Properties']['AvailabilityZone']['Fn::Select'][0]))
                        logger.info('PrivSn' + str(i) + ' after CIDR index:  {}'.format(fragment['Resources']['VPCPrivSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][0]))
                        logger.info('PrivSn' + str(i) + ' after CIDR:  {}'.format(fragment['Resources']['VPCPrivSn' + str(i)]['Properties']['CidrBlock']['Fn::Select'][1]))
                        fragment['Resources']['VPCPrivSn' + str(i)]['Properties']['Tags'][0]['Value']['Fn::Sub'] = '${VPCName}_vpc_private_subnet_' + str(i)

                        # Append all the additional Outputs onto the fragment.
                        # if not i == 1:   
                        # Create new Outputs for Public RT Association
                        fragment['Resources']['VPCPubSn' + str(i) + 'RtAssoc'] = {}
                        fragment['Resources']['VPCPubSn' + str(i) + 'RtAssoc']['Type'] = 'AWS::EC2::SubnetRouteTableAssociation'
                        fragment['Resources']['VPCPubSn' + str(i) + 'RtAssoc']['Properties'] = {}
                        fragment['Resources']['VPCPubSn' + str(i) + 'RtAssoc']['Properties']['RouteTableId'] = {}
                        fragment['Resources']['VPCPubSn' + str(i) + 'RtAssoc']['Properties']['RouteTableId']['Ref'] = 'VPCPubRt1'
                        fragment['Resources']['VPCPubSn' + str(i) + 'RtAssoc']['Properties']['SubnetId'] = {}
                        fragment['Resources']['VPCPubSn' + str(i) + 'RtAssoc']['Properties']['SubnetId']['Ref'] = 'VPCPubSn' + str(i)

                        # Create new Outputs for Private RT Association
                        fragment['Resources']['VPCPrivSn' + str(i) + 'RtAssoc'] = {}
                        fragment['Resources']['VPCPrivSn' + str(i) + 'RtAssoc']['Type'] = 'AWS::EC2::SubnetRouteTableAssociation'
                        fragment['Resources']['VPCPrivSn' + str(i) + 'RtAssoc']['Properties'] = {}
                        fragment['Resources']['VPCPrivSn' + str(i) + 'RtAssoc']['Properties']['RouteTableId'] = {}
                        fragment['Resources']['VPCPrivSn' + str(i) + 'RtAssoc']['Properties']['RouteTableId']['Ref'] = 'VPCPrivRt1'
                        fragment['Resources']['VPCPrivSn' + str(i) + 'RtAssoc']['Properties']['SubnetId'] = {}
                        fragment['Resources']['VPCPrivSn' + str(i) + 'RtAssoc']['Properties']['SubnetId']['Ref'] = 'VPCPrivSn' + str(i)
                        
                        # Create new Outputs for NAT Gateway per public subnet
                        # not needed
                        
                        # Create new Outputs for NAT Gateway EIP per NAT Gateway
                        # not needed
                        
                        # Create new Outputs for public subnet IDs
                        fragment['Outputs']['StackVPCPubSn' + str(i)] = {}
                        fragment['Outputs']['StackVPCPubSn' + str(i)]['Description'] = 'The ID of the public subnet' + str(i)
                        fragment['Outputs']['StackVPCPubSn' + str(i)]['Value'] = {}
                        fragment['Outputs']['StackVPCPubSn' + str(i)]['Value']['Ref'] = 'VPCPubSn' + str(i)
                        fragment['Outputs']['StackVPCPubSn' + str(i)]['Export'] = {}
                        fragment['Outputs']['StackVPCPubSn' + str(i)]['Export']['Name'] = {}
                        fragment['Outputs']['StackVPCPubSn' + str(i)]['Export']['Name']['Fn::Sub'] = '${VPCName}-PublicSubnet' + str(i) + '-ID'
                        logger.info('PubSn' + str(i) + ' after create Outputs: {}'.format(fragment['Outputs']))

                        # Create new Outputs for public subnet CIDRs
                        fragment['Outputs']['StackVPCPubSn' + str(i) + 'CIDR'] = {}
                        fragment['Outputs']['StackVPCPubSn' + str(i) + 'CIDR']['Description'] = 'The CIDR of the public subnet' + str(i)
                        fragment['Outputs']['StackVPCPubSn' + str(i) + 'CIDR']['Value'] = {}
                        fragment['Outputs']['StackVPCPubSn' + str(i) + 'CIDR']['Value']['Fn::GetAtt'] = 'VPCPubSn' + str(i) + '.CidrBlock'
                        fragment['Outputs']['StackVPCPubSn' + str(i) + 'CIDR']['Export'] = {}
                        fragment['Outputs']['StackVPCPubSn' + str(i) + 'CIDR']['Export']['Name'] = {}
                        fragment['Outputs']['StackVPCPubSn' + str(i) + 'CIDR']['Export']['Name']['Fn::Sub'] = '${VPCName}-PublicSubnet' + str(i) + '-CIDR'
                        logger.info('PubSnCIDR' + str(i) + ' after create Outputs: {}'.format(fragment['Outputs']))

                        # Create new Outputs for public subnet Route Tables
                        fragment['Outputs']['StackVPCPubSn' + str(i) + 'RT'] = {}
                        fragment['Outputs']['StackVPCPubSn' + str(i) + 'RT']['Description'] = 'The Route Table of the public subnet' + str(i)
                        fragment['Outputs']['StackVPCPubSn' + str(i) + 'RT']['Value'] = {}
                        fragment['Outputs']['StackVPCPubSn' + str(i) + 'RT']['Value']['Ref'] = 'VPCPubSn' + str(i)
                        fragment['Outputs']['StackVPCPubSn' + str(i) + 'RT']['Export'] = {}
                        fragment['Outputs']['StackVPCPubSn' + str(i) + 'RT']['Export']['Name'] = {}
                        fragment['Outputs']['StackVPCPubSn' + str(i) + 'RT']['Export']['Name']['Fn::Sub'] = '${VPCName}-PublicSubnet' + str(i) + '-RouteTable'
                        logger.info('PubSnRt' + str(i) + ' after create Outputs: {}'.format(fragment['Outputs']))

                        # Create new Outputs for private subnet IDs
                        fragment['Outputs']['StackVPCPrivSn' + str(i)] = {}
                        fragment['Outputs']['StackVPCPrivSn' + str(i)]['Description'] = 'The ID of the private subnet' + str(i)
                        fragment['Outputs']['StackVPCPrivSn' + str(i)]['Value'] = {}
                        fragment['Outputs']['StackVPCPrivSn' + str(i)]['Value']['Ref'] = 'VPCPrivSn' + str(i)
                        fragment['Outputs']['StackVPCPrivSn' + str(i)]['Export'] = {}
                        fragment['Outputs']['StackVPCPrivSn' + str(i)]['Export']['Name'] = {}
                        fragment['Outputs']['StackVPCPrivSn' + str(i)]['Export']['Name']['Fn::Sub'] = '${VPCName}-PrivateSubnet' + str(i) + '-ID'
                        logger.info('PrivSn' + str(i) + ' after create Outputs: {}'.format(fragment['Outputs']))

                        # Create new Outputs for private subnet CIDRs
                        fragment['Outputs']['StackVPCPrivSn' + str(i) + 'CIDR'] = {}
                        fragment['Outputs']['StackVPCPrivSn' + str(i) + 'CIDR']['Description'] = 'The CIDR of the private subnet' + str(i)
                        fragment['Outputs']['StackVPCPrivSn' + str(i) + 'CIDR']['Value'] = {}
                        fragment['Outputs']['StackVPCPrivSn' + str(i) + 'CIDR']['Value']['Fn::GetAtt'] = 'VPCPrivSn' + str(i) + '.CidrBlock'
                        fragment['Outputs']['StackVPCPrivSn' + str(i) + 'CIDR']['Export'] = {}
                        fragment['Outputs']['StackVPCPrivSn' + str(i) + 'CIDR']['Export']['Name'] = {}
                        fragment['Outputs']['StackVPCPrivSn' + str(i) + 'CIDR']['Export']['Name']['Fn::Sub'] = '${VPCName}-PrivateSubnet' + str(i) + '-CIDR'
                        logger.info('PrivSnCIDR' + str(i) + ' after create Outputs: {}'.format(fragment['Outputs']))

                        # Create new Outputs for private subnet Route Tables
                        fragment['Outputs']['StackVPCPrivSn' + str(i) + 'RT'] = {}
                        fragment['Outputs']['StackVPCPrivSn' + str(i) + 'RT']['Description'] = 'The Route Table of the private subnet' + str(i)
                        fragment['Outputs']['StackVPCPrivSn' + str(i) + 'RT']['Value'] = {}
                        fragment['Outputs']['StackVPCPrivSn' + str(i) + 'RT']['Value']['Ref'] = 'VPCPrivSn' + str(i)
                        fragment['Outputs']['StackVPCPrivSn' + str(i) + 'RT']['Export'] = {}
                        fragment['Outputs']['StackVPCPrivSn' + str(i) + 'RT']['Export']['Name'] = {}
                        fragment['Outputs']['StackVPCPrivSn' + str(i) + 'RT']['Export']['Name']['Fn::Sub'] = '${VPCName}-PrivateSubnet' + str(i) + '-RouteTable'
                        logger.info('PubSnRt' + str(i) + ' after create Outputs: {}'.format(fragment['Outputs']))

                    # Function Inputs
                    logger.info('Output Event: event{}'.format(event))
                     
                    # Return from the function
                    r = {}
                    r['requestId'] = requestId
                    r['status'] = 'SUCCESS'
                    r['fragment'] = fragment

                    return r

            Handler: index.handler
            Runtime: python3.9
            Timeout: '60'
            MemorySize: '256'
            Role: !GetAtt TransformExecutionRole.Arn
            Tags:
                - Key: Name
                  Value: 'Public_Subnet_per_AZ_Macro_Lambda_Function'
                - Key: Owner
                  Value: !Ref OwnerTag
                - Key: Project
                  Value: !Ref ProjectTag
                - Key: Environment
                  Value: !Ref EnvironmentTag
                - Key: created_by
                  Value: !Ref CreatedByTag
                - Key: create_date
                  Value: !Ref CreatedDateTag
                - Key: delete_after
                  Value: !Ref DeleteAfterTag
                - Key: created_method
                  Value: !Ref CreatedMethodTag
                - Key: team
                  Value: !Ref TeamTag

    Transform:
        Type: AWS::CloudFormation::Macro
        Properties:
            Name: CreateSubnetsPerAZ
            Description: Macro to create Subnets for every available AZ
            FunctionName: !GetAtt TransformFunction.Arn
